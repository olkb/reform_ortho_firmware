#include "reform_sysctl.h"
#include "serial_vendor.h"

char command_response[256] = {0};
    
char * remote_try_command(char* cmd, bool print) {
    bool ok = false;

    char outgoing[4] = {0};
    strcpy(outgoing, cmd);
    outgoing[strlen(cmd)] = '\r';
    serial_clear();
    serial_send((uint8_t*)outgoing, strlen(outgoing));

    memset(command_response, 0, 255);
    for (int tries = 0; tries < 2; tries++) {
        serial_receive_timeout((uint8_t*)command_response, 255, 200);
        ok = strlen(command_response);

        if (!ok && tries == 0 && false) {
           try_wake(print);
           serial_clear();
        }
        if (ok) {
            if (print) {
                oled_clear();
                oled_write(command_response, false);
            }
            break;
        }
    }
    if (!ok && print && false) {
        oled_clear();
        oled_write("No response from LPC", false);
    }

    serial_clear();
    return command_response;
}

char command_response_sized[256] = {0};
char * remote_try_command_size(char* cmd, bool print, uint8_t expected_size) {
    uint8_t size = 0;

    char outgoing[4] = {0};
    strcpy(outgoing, cmd);
    outgoing[strlen(cmd)] = '\r';
    serial_clear();
    serial_send((uint8_t*)outgoing, strlen(outgoing));

    memset(command_response_sized, 0, 255);

    if (expected_size == 0) {
        serial_clear();
        return command_response_sized;
    }

    //wait_ms(100);

    char * current_pos = command_response_sized;
    bool status;
    bool received_bytes;
    int i = 0;

    sync_rx(TIME_MS2I(200));
    while (serial_has_rx()) {
        *(current_pos++) = serial_getc();      
        i++;

        msg_t msg = sync_rx(TIME_MS2I(200));
        if (msg < MSG_OK) {
            break;
        }
    } 
    /*
    do {
        msg_t msg = sync_rx(TIME_MS2I(200));
        if (msg < MSG_OK) {
            break;
        }
        // status = serial_receive_timeout(current_pos, expected_size - strlen(command_response_sized), 20);
        // status = serial_receive_timeout((uint8_t*)current_pos, 255 - strlen(command_response_sized), 50);
        // while(s)
        *(current_pos++) = serial_getc();
        // char * new_current_pos = &command_response_sized[strlen(command_response_sized)];
        // received_bytes = new_current_pos > current_pos;
        // current_pos = new_current_pos;
        i++;
    // } while ((strlen(command_response_sized) < expected_size || status) && strlen(command_response_sized) < 255 && received_bytes);
    } while (i < expected_size);
    */
    // } while (strlen(command_response_sized) < expected_size && i < 16);
    size = strlen(command_response_sized);
    //for (int i = 0; i < size; i++) {
    //    virtser_send(command_response_sized[i]);
    //}
    // print(command_response_sized);

    if (size == expected_size && print) {
        oled_clear();
        oled_write(command_response_sized, false);
    } else if (print) {
        //oled_clear();
        //char sizeStr[4] = {0};
        //sprintf(sizeStr, "%d", size);
        //oled_write("Size: ", false);
        //oled_write(sizeStr, false);
    }

    serial_clear();
    return command_response_sized;
}

bool try_wake(bool print) {
    bool ok = false;
    char buffer[256] = {0};
    char strBuffer[64] = {0};
    for (int i = 0; i < 400; i++) {
        if (print) {
            oled_clear();
            sprintf(strBuffer, "Waking up LPC... %d%%", i/4);
            oled_write(strBuffer, false);
        }
        serial_send((uint8_t*)"a\r", 2);
        wait_ms(25);

        serial_receive((uint8_t*)buffer, 255);
        if (strlen(buffer)) {        
            if (print) { 
                oled_clear();
                oled_write(buffer, false);
            }
            ok = true;
            break;
        }
        wait_ms(25);
    } 
    serial_send((uint8_t*)"\r", 1);
    wait_ms(10);
    do {
        memset(buffer, 0, 255);
        serial_receive((uint8_t*)buffer, 255);
        wait_ms(25);
    } while(strlen(buffer));
    return ok;
}

void render_mnt_logo(void) {
    #ifdef OLED_ENABLE
    static const char PROGMEM mnt_logo[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xe0, 0xc0, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xe0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xe0,
0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
0x7f, 0xfe, 0xfc, 0xf8, 0xf0, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xfc, 0xf8, 0xf0, 0xff, 0xff,
0xff, 0xff, 0x7f, 0xfe, 0xfc, 0xf8, 0xf0, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03,
0x00, 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0x00, 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f,
0x3f, 0x7f, 0x00, 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff,
0x03, 0xdb, 0xdb, 0x27, 0xff, 0x03, 0xdb, 0xdb, 0xdb, 0xff, 0x07, 0xdb, 0xdb, 0xfb, 0xff, 0x07,
0xfb, 0xfb, 0xfb, 0x07, 0xff, 0x03, 0xdb, 0xdb, 0x27, 0xff, 0x03, 0xf7, 0xef, 0xdf, 0xef, 0xf7,
0x03, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07,
0x06, 0x07, 0x07, 0x06, 0x07, 0x06, 0x06, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07,
0x06, 0x06, 0x06, 0x07, 0x07, 0x06, 0x07, 0x07, 0x06, 0x07, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07,
0x06, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };

    oled_write_raw_P(mnt_logo, sizeof(mnt_logo));
    #endif
}